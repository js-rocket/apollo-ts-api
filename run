#!/bin/bash
APP_NAME=myapi
NET_NAME=bridge1

# Database container details - leave DBAPP_NAME if you want to run your own database
DBAPP_NAME=${APP_NAME}_db
DB_PORT=5432
DBUSER_NAME=dev_user
DBUSER_PASS=devpassword837439

# Possible values are: heroku, aws, vercel, gcp
DEPLOY_TARGET=aws

# Deployment: heroku
HEROKU_DEPLOY_SSH_KEY=~/ssh_certs/heroku1

# Deplyoment: AWS
AWS_AMPLIFY_APP_ID=xxxxXXXXX
AWS_LAMBDA_FUNCTION=xxxxXXXXX

# set to zero if you want to use you own local database for testing
USE_DOCKER_DB=0


update_package_json() {
  echo "const fs = require('fs'), PKG='package.json', pkg = JSON.parse(fs.readFileSync(PKG, 'utf8'))
pkg.main = 'src/index.js'
pkg.engines = { node : '>=10.0.0' }
pkg.scripts = {
  start: 'node ./dist/server.js',
  dev: 'webpack --watch',
  test: 'yarn jest',
  sq: 'sequelize-cli',
  'lint': 'eslint ./src ./database',
  'lint:fix': 'eslint --fix ./src ./database',
  'pretty': 'prettier -c ./src',
  'pretty:fix': 'prettier -w ./src'
}
fs.writeFileSync(PKG, JSON.stringify(pkg, null, 2));
" | node -
}


app_init() { 
  yarn init -y
  # add expressjs and graphql
  # @babel/runtime
  APPDEPS="ajv ajv-formats lodash moment-timezone chance graphql 
    express apollo-server-express sequelize pg jwt-simple axios"

  if [ $DEPLOY_TARGET == "aws" ]; then
    APPDEPS="$APPDEPS aws-serverless-express apollo-server-lambda"
  fi

  yarn add $APPDEPS

  # Add webpack, babel transpiler, eslint, prettier and jest/supertest
  yarn add -D webpack webpack-cli webpack-node-externals raw-loader \
    typescript ts-loader @types/node @types/validator @types/jest \
    eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin \
    prettier eslint-plugin-prettier eslint-config-prettier \
    jest ts-jest supertest @types/supertest \
    sequelize-cli
  
  # yarn add -D webpack webpack-cli webpack-node-externals \
  #   @babel/core @babel/preset-env babel-loader babel-plugin-inline-import @babel/plugin-transform-runtime \
  #   eslint eslint-plugin-prettier eslint-config-prettier prettier \
  #   eslint-config-airbnb-base eslint-plugin-import eslint-import-resolver-alias \
  #   jest supertest \
  #   sequelize-cli

  update_package_json
}


app_reset() {
  rm -rf ./node_modules ./dist
  rm package.json yarn.lock package-lock.json yarn-error.log
}


app_stop() {
  # stop database server
  if [ $USE_DOCKER_DB == 1 ]; then docker-compose stop; fi
}


app_dev() {
  # start database server
  if [ $USE_DOCKER_DB == 1 ]; then
    if [ ! -d "./docker/data" ]; then mkdir -p "./docker/data"; fi
    docker-compose up -d;
    sleep 5
  fi
  # run node file
  yarn webpack --watch --mode development
}


app_build() {
  echo "Building"
  if [ ! -d "./dist" ]; then mkdir ./dist; fi
  if [ -d "./public" ]; then cp -f ./public/* ./dist/; fi
  # yarn webpack --mode development $1
  yarn webpack --mode production $1
}


app_test() {
  yarn jest
}


app_sequelize() {
  yarn sequelize --env dev $*
}


app_deploy_aws() {
  echo "Deploying"
  # note down currnt project dependancies
  DEPS=$(echo "const fs = require('fs'), PKG='package.json', pkg = JSON.parse(fs.readFileSync(PKG, 'utf8'))
console.log(JSON.stringify(pkg.dependencies,null,2))
" | node -)

  # clear deploy directory and recreate
  rm -rf ./deploy/awsamp
  mkdir -p ./deploy/awsamp
  cd ./deploy/awsamp

  AMPLIFY_CONFIG="{\"SourceDir\":\"src\",\"DistributionDir\":\"build\",\"BuildCommand\":\"echo building\",\"StartCommand\":\"echo starting\"}"
  AMPLIFY_PROVIDER="{\"awscloudformation\":{\"useProfile\":false,
  \"accessKeyId\":\"$AWS_ACCESS_KEY_ID\",\"secretAccessKey\":\"$AWS_SECRET_ACCESS_KEY\",\"region\":\"$AWS_DEFAULT_REGION\"}}"

  #pull down amplify project
  amplify pull --amplify "{\"appId\":\"$AWS_AMPLIFY_APP_ID\",\"envName\":\"$AWS_STAGE\",\"defaultEditor\":\"code\"}" \
  --providers "$AMPLIFY_PROVIDER" \
  --frontend "{\"frontend\":\"javascript\",\"framework\":\"none\",\"config\":$AMPLIFY_CONFIG}" --yes

  # remove existing content and copy new content
  AWS_API_SRC_PATH=./amplify/backend/function/$AWS_LAMBDA_FUNCTION/src
  rm -rf $AWS_API_SRC_PATH
  mkdir -p $AWS_API_SRC_PATH
  cp ../../dist/server.js $AWS_API_SRC_PATH/index.js

  echo "{
  \"name\": \"$AWS_LAMBDA_FUNCTION\",
  \"version\": \"1.0.0\",
  \"main\": \"index.js\",
  \"dependencies\": $DEPS
}" > $AWS_API_SRC_PATH/package.json

  # push new content to the cloud
  amplify push --providers "$AMPLIFY_PROVIDER" --yes
  PUSH_EXIT_STATUS=$?
  cd ../../

  echo "Sent to AWS"
  exit $PUSH_EXIT_STATUS
}


app_deploy_heroku() {
  echo "Building"
  app_build

  echo "Deploying"
  DEPS=$(echo "const fs = require('fs'), PKG='package.json', pkg = JSON.parse(fs.readFileSync(PKG, 'utf8'))
console.log(JSON.stringify(pkg.dependencies,null,2))
" | node -)

  rm -rf ./deploy/heroku/
  mkdir ./deploy/heroku
  cd ./deploy/heroku

  git init
  git remote add heroku ssh://git@heroku.com/trl-tester.git
  sleep 1
  GIT_SSH_COMMAND="ssh -i $HEROKU_DEPLOY_SSH_KEY" git pull heroku master
  sleep 2
  rm -f server.js index.html main.js

  echo "{
  \"name\": \"api\",
  \"version\": \"1.0.0\",
  \"main\": \"server.js\",
  \"dependencies\": $DEPS,
  \"scripts\": {
    \"start\": \"node server.js\"
  }
}" > ./package.json
  echo "node_modules/" > ./.gitignore

  cp -R ../../dist/* .
  git add * .gitignore
  git commit -m "deploy commit"

  GIT_SSH_COMMAND="ssh -i $HEROKU_DEPLOY_SSH_KEY" git push --set-upstream heroku master
  cd ../..
  # rm -rf ./deploy/heroku/

  echo "Sent to heroku"
}


app_set_environment() {
  NODE_SET_ENV=$(echo "print=console.log; dbfields = process.env.DATABASE_URL.match(/postgres:\/\/(.*):(.*)@(.*):(.*)\/(.*)/);
  print('DB_USER='+dbfields[1]);
  print('DB_PASSWORD=' + decodeURIComponent(dbfields[2]) );
  print('DB_HOST=' + dbfields[3]);
  print('DB_PORT=' + dbfields[4]);
  print('DB_NAME=' + dbfields[5]);
" | node -)
  eval "$NODE_SET_ENV"
  NODE_SET_ENV=''
}


app_debug() {
  DEPS=$(echo "const fs = require('fs'), PKG='package.json', pkg = JSON.parse(fs.readFileSync(PKG, 'utf8'))
console.log(JSON.stringify(pkg.dependencies,null,2))
" | node -)
echo $DEPS
}


app_dist() {
  node dist/server.js
}


docker_dbstart() {
  docker_dbstop
  docker run -dit --rm \
  -p $DB_PORT:5432 \
  --net $NET_NAME \
  -v $PWD/docker/data:/var/lib/postgresql \
  -e POSTGRES_USER=$DBUSER_NAME \
  -e POSTGRES_PASSWORD=$DBUSER_PASS \
  --name="$DBAPP_NAME" postgres:12-alpine
}


docker_dbstop() {
  docker stop -t 2 $DBAPP_NAME
}


# Create database and user according to .env file values
docker_dbinit() {
  echo "CREATING: $DB_NAME"
  docker exec $DBAPP_NAME /usr/local/bin/psql \
    "postgresql://$DBUSER_NAME:$DBUSER_PASS@localhost/postgres" \
    -c "CREATE DATABASE $DB_NAME;"

  INIT_SCRIPT="CREATE USER $DB_USER WITH PASSWORD '$DB_PASSWORD';
  GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;"

  docker exec $DBAPP_NAME /usr/local/bin/psql \
    "postgresql://$DBUSER_NAME:$DBUSER_PASS@localhost/$DB_NAME" \
    -c "$INIT_SCRIPT"
}


docker_dbimport() {
  echo "IMPORTING: $1"
  docker exec -i $DBAPP_NAME /usr/local/bin/psql \
    "postgresql://$DBUSER_NAME:$DBUSER_PASS@localhost/$DB_NAME" < $1
}


app_hook_link() {
  ln -s ../../hooks/pre-commit .git/hooks/pre-commit
}


# import environment variables for local testing
set -a; if [ -f '.env' ]; then source .env; fi; app_set_environment; set +a

if [ "$1" == "init" ]; then app_init; exit; fi
if [ "$1" == "reset" ]; then app_reset; exit; fi
if [ "$1" == "hook" ]; then app_hook_link; exit; fi

if [ "$1" == "dev" ]; then app_dev; exit; fi
if [ "$1" == "stop" ]; then app_stop; exit; fi

if [ "$1" == "build" ]; then app_build $2; exit; fi
if [ "$1" == "dist" ]; then app_dist $2; exit; fi

if [ "$1" == "sq" ]; then shift 1; app_sequelize $*; exit; fi

if [ "$1" == "test" ]; then yarn test; exit; fi
if [ "$1" == "lint" ]; then yarn lint; exit; fi

if [ "$1" == "deploy-heroku" ]; then app_deploy_heroku; exit; fi
if [ "$1" == "deploy-aws" ]; then app_deploy_aws; exit; fi

if [ "$1" == "debug" ]; then app_debug; exit; fi


# database commands
if [ "$1" == "dbstart" ]; then docker_dbstart; exit; fi
if [ "$1" == "dbstop" ]; then docker_dbstop; exit; fi

if [ "$1" == "dbinit" ]; then docker_dbinit $2; exit; fi
if [ "$1" == "dbimport" ]; then docker_dbimport $2; exit; fi

echo "Command not found"
